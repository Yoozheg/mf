XJSL - Расширяемый JS Фреймворк для работы с DOM, cookie, Ajax, хранилищем и т д.
=========
Список файлов

	xjsl.js - сама библиотека. пишется одним файлом, пока нет сборщика
	plugins/ - папка с примерами плагинов
	plugins/*.js - плагины
	plugins/dom/*.js - плагины, расширяющие метод $.DOM

Подключение библиотеки
----------
В шапке сайта необходимо указать путь до библиоткеи

	<head>
	 ...
	 <script src="path/to/xjsl.js"></script>
	</head>

Библиотека занимает в глобальной области видимости объект `$`.
Если вы хотите сохранить какое-либо другое своё значение для этой переменной, вам следует вызвать функцию `$.conflict()`, которая восстанавливает исходное значение переменной `$`, и возвращает объект библиотеки, который вы можете присвоить любой другой переменной.

	<script>
	 var xjsl = $.conflict();
	</script>

Подключение плагинов
----------
Библиотека способна расширять свой функционал с помошью дополнительных модулей - плагинов.
Плагины могут расширять и стандартный функционал библиотеки и методы DOM.

	<head>
	 ...
	 <script src="path/to/xjsl.js"></script>
	 ...
	 <script src="path/to/xjsl/plugins/someplugin.js"></script>
	</head>

Примечание.
Плагины расширяют функционал библиотеки, добавляя методы в `$`.
Если вы вызываете `$.conflict()`, то вам нужно  учесть это.

Использование XJSL
=========
работа с DOM
---------
За поиск элементов в дереве DOM и работу с ними отвечает функция `$(element)`.
Поиск осущетсвляется по селектору CSS
При чём, по умолчанию функция возвращает 1 элемент, первый в дереве, удовлетворивший запросу.
Для того, чтобы функция вернула все элементы, необходимо заключать параметр в квадратные скобки.
Если среди всех найденных вы хотите продолжить работу с одним конкретным элементом, используйте функцию `$(element).q(index)`. Не забывайте, что индексация начинается с нуля.

	var firstDIV = $('div'); //найдёт первый DIV на странице
	var allDIVS = $(['div']); //найдёт все DIV на странице
	var secondDIV = allDIVS.q(1); //найдёт второй DIV на странице
	
создание элементов
	var newNode = new $('div'); //создание нового узла
	$(document.body).add(newNode) //добавляет новый узел в конец body

Со всеми элементами DOM поддерживаются следующие действия
* `$(element).html()` - возвращает HTML, содержащийся в element
* `$(element).html(code)` - устанавливает HTML в element
* `$(element).clear()` - удаляет всё, содержащееся в element
* `$(element).add(newNode)` - добавляет в element новый элемент newNode и переходит к нему
* `$(element).css()` - возвращает style, применённый к element
* `$(element).css(code)` - устанавливает style в element
* `$(element).attr(name)` - возвращает значение атрибута name у element
* `$(element).attr(name, value)` - устанавливает значение атрибута name в value у element
* `$(element).attr({name_1: value_1, name_2: value_2, ... name_n: value_n)` - устанавливает значение группы атрибутов name_k в value_k у element, где k = 1..n
* `$(element).val()` - возвращает значение value у element (если поддерживаются, т.е. для элементов форм)
* `$(element).val(code)` - устанавливает значение value у element в code (если поддерживаются, т.е. для элементов форм)
* `$(element).on({ev_1: fn_1, ev_2: fn_2, ... ev_n: fn_n)` - 'вешает' события на элемент element
* `$(element).off({ev_1: fn_1, ev_2: fn_2, ... ev_n: fn_n)` - 'снимат' события с элемента element
* `$(element).off(ev_type)` - снимает все обработчики события ev_type с element
* `$(element).off()` - снимает все обработчики событий с element
* `$(element).show()` - показывает element
* `$(element).hide()` - прячет element
* `$(element).toggle()` - показывает element, если он спрятан, либо прячет, если показан
* `$(element).cls()` - возвращает значение className у элемента
* `$(element).cls(code)` - устанавливает значение className в code у элемента
* `$(element).addClass(code)` - добавляет класс code в className элемента element
* `$(element).removeClass(code)` - удаляет класс code из className элемента element
* `$(element).toggleClass(code)` - 'переключает' класс code в className элемента element
* `$(element).get()` - возвращает элемент element
* `$(element).load(addr)` - загружает в html element данные с сервера по адресу addr
* `$(element).load(addr, text)` - аналогично, только на сервер передаются данные text
* `$(element).animate(params, type, duration, callback)` - анимация элемента element
* `$(element).rm()` - удаление элемента element
* `$(element).first()` - возвращает первый дочерний узел
* `$(element).last()` - возвращает последний дочерний узел
* `$(element).next()` - переходит к следующему элементу в дереве
* `$(element).prev()` - переходит к предыдущему элементу в дереве
* `$(element).neighbours(elementTwo)` - возвращает true, если элементы element и elementTwo соседи
* `$(element).child()` - возвращает все дочерние узлы у element
* `$(element).coords()` - возвращает все координаты element

остальные функции
----------
* `$.ready(handler)` - выполнит handler при готовности документа
* `$.cookie(name, value, props)` - записыывает/читает cookie
* `$.storage(item, value)` - работа с хранилищем, item, value - строки; если итем - число, то вернёт название ключа, если итем == -1 - очистит хранилище, нет параметров - длина
* `$.ajax(text, addr, callback, json, method)` - запрос с сервера
* `$.proxy(func, context /*, args*/)` - выполняет func в контексте context //Синтаксис: (func, context, аргументы) или (obj, 'method', аргументы)
* `$.copy(dst /*, args*/)` - копирует в dst аргументы
* `$.esc(string)` - экранирует строку
* `$.delay(f, ms)` - запускает fn раз в ms милисекунд
* `$.bounce(fn, delay, ctx)` - Возвращает функцию, вызывающую исходную с задержкой delay в контексте ctx. Если во время задержки функция была вызвана еще раз, то предыдующий вызов отменяется, а таймер обновляется. Таким образом из нескольких вызовов, совершающихся чаще, чем delay, реально будет вызван только последний
* `$.debounce(f, ms)` - передаёт вызов f не чаще, чем раз в ms миллисекунд
* `$.throttle(f, ms)` - возвращает обёртку, передающую вызов f не чаще, чем раз в ms миллисекунд. если игнорируемый вызов оказался последним — то он выполнится

За более подробной информацией вам лучше обратиться к документации
